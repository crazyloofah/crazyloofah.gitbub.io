{% extends 'base.html' %}
{% block content %}
<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
</head>
<body>

    <script>
      //The config object is how you configure your Phaser Game
      //we're just going to set the renderer, dimensions and a default Scene.
    var config = {
      //The type property can be either Phaser.CANVAS, Phaser.WEBGL, 
      //or Phaser.AUTO. This is the rendering context that you want to use for your game due to it having the ability to use both
        type: Phaser.AUTO,
        //width and height in pixels
        width: 768,
        height: 416,

        physics: {
            default: 'arcade',
            arcade: {
                gravity: {y: 400},
                debug: false
            }
        },
        scene: {
          //Phaser will automatically look for this function when it starts and load anything defined within it
            preload: preload,
            create: create,
            update: update,
        }
    };

    var game = new Phaser.Game(config);
    var platforms;
    var cursors;
    var character;
    var score = 0;
    var scoreText;

    function preload ()
    ////Phaser will automatically look for this function when it starts and load anything defined within it
    {
      {
      this.load.image('sky0', 'assets/Final/Background_0.png');
      this.load.image('sky1', 'assets/Final/Background_1.png');
      this.load.image('enemy', 'assets/matts-badger.png');
      this.load.image('star', 'assets/star.png');
      this.load.image('ground', 'assets/platform.png');
      this.load.image('tiles', 'assets/tilesets/oak_woods_tileset.png');
      this.load.tilemapTiledJSON('map', 'assets/tilemaps/level3.json');
      this.load.atlas('character', 'assets/test/robspritesheet.png', 'assets/test/robsprites.json');
      }
    }
    function create ()
    //In order to display the images, maps, pretty much everything -
    //we've loaded we need to pull that info from the preload function -
    //and create our '''hence the name of the function''' and load all of our images on the screen
    { 
      {
        //loading our background and assigning them to a variable so that we can -
        //use that said variable later on and keep the background in place as we -
        //move our character
        bg0 = this.add.image(384, 208, 'sky0');
        bg1 = this.add.image(384, 208, 'sky1');
        
        //creating a variable called map that we can use to plug in for our tiled map
        const map = this.make.tilemap({ key: 'map' });
        //creating a variable called tileset so that we can throw map inside of it and plug our key and value into it
        const tileset = map.addTilesetImage('matt_simple_platformer', 'tiles');
        //creating a variable called platforms and giving it the name platform as well as giving it the -
        //variable tileset that we created as a key/value pair and giving it a starting postion.
        const platforms = map.createStaticLayer('Platform', tileset, 0, 0);
        //allows us to collide with the map.
        platforms.setCollisionByExclusion(-1, true);

        //loading in our sprite and and pulling certain images from it using its json file
        this.anims.create({key: 'standing', frames: this.anims.generateFrameNames('character', { prefix: 'standing', end: 1, zeroPad: 4 } 
        ), repeat: -1});
        this.anims.create({key: 'running', frames: this.anims.generateFrameNames('character', { prefix: 'running', end: 23, zeroPad: 4 } 
        ), repeat: -1});
        this.anims.create({key: 'jump', frames: this.anims.generateFrameNames('character', { prefix: 'jump', end: 13, zeroPad: 4 } 
        ), repeat: 0});
        //this.physics allows us to ultimately collide with the ground once fiddled with just a little 
        //this loads in our sprite by calling the key of character and then the 350 and 100 is the -
        //starting postion of our X and Y coordinates
        character = this.physics.add.sprite(350, 100,  'character');
        //this allows us to land on our tiled map that we created
        this.physics.add.collider(character, platforms);
        //this allows us to plug in certain inputs using the keyboard later on in the update function
        cursors = this.input.keyboard.createCursorKeys();

        //this is creating our items for our game. In this instance we are just going to place stars -
        //and collect them for our some sort of functionality
        stars = this.physics.add.group({
          key: 'star',
          //how many there are
          repeat: 5,
          //setting where it starts on the x coordinate and y coordinate as well as how far apart they are
          setXY: { x: 40, y: 200, stepX: 250 }
          });
          stars.children.iterate(function (child) {
          child.setBounceY(Phaser.Math.FloatBetween(0.4, 0.8));
          });
          //collider for stars and platforms
          this.physics.add.collider(stars, platforms);
          //this is to get rid of the star once overlapped
          this.physics.add.overlap(character, stars, collectStar, null, this);
        

          //scoretext and function for adding score after collecting it
        scoreText = this.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#fff' });
        function collectStar (player, star)
        {
          star.disableBody(true, true);
          score += 10;
          scoreText.setText('Score: ' + score);
          }
        camera = this.cameras.main;
        camera.setBounds(0, 0, 2500, 800);
        camera.startFollow(character, true, 0.05, 0.05, -200, 120);

        hud = this.add.container(0, 0, [scoreText, ]);
        //lock it to the camera
        hud.setScrollFactor(0);
        bg0.setScrollFactor(0);
        bg1.setScrollFactor(0);

        

    }
  }

  function update ()
  {
  



      if (cursors.left.isDown){    
        character.setVelocityX(-160);
        character.flipX = false;
        if (character.body.onFloor()){
        character.anims.play('running', true);
        }
      } else if (cursors.right.isDown){
        character.setVelocityX(160);
        character.flipX = true;
        if (character.body.onFloor()){
        character.anims.play('running', true);}
      } else {
        
        character.setVelocityX(0);
        character.play('standing');
      }
      if (cursors.up.isDown && character.body.onFloor()){
        character.setVelocityY(-330);
        character.play('jump')
      }
    }
    </script>

</body>
</html>
{% endblock %}
